"site","date","headline","url_address","text"
"vidhya",2018-12-06,"A Practical Guide to Object Detection using the Popular YOLO Framework <U+2013> Part III (with Python codes)","https://www.analyticsvidhya.com/blog/2018/12/practical-guide-object-detection-yolo-framewor-python/","How easy would our life be if we simply took an already designed framework, executed it, and got the desired result? Minimum effort, maximum reward. Isn¡¯t that what we strive for in any profession? I feel incredibly lucky to be part of our machine learning community where even the top tech behemoths embrace open source technology. Of course it¡¯s important to understand and grasp concepts before implementing them, but it¡¯s always helpful when the ground work has been laid for you by top industry data scientists and researchers. This is especially true for deep learning domains like computer vision. Not everyone has the computational resources to build a DL model from scratch. That¡¯s where predefined frameworks and pretained models come in handy. And in this article, we will look at one such framework for object detection <U+2013> YOLO. It¡¯s a supremely fast and accurate framework, as we¡¯ll see soon. So far in our series of posts detailing object detection (links below), we¡¯ve seen the various algorithms that are used, and how we can detect objects in an image and predict bounding boxes using algorithms of the R-CNN family. We have also looked at the implementation of Faster-RCNN in Python. In part 3 here, we will learn what makes YOLO tick, why you should use it over other object detection algorithms, and the different techniques used by YOLO. Once we have understood the concept thoroughly, we will then implement it it in Python. It¡¯s the ideal guide to gain invaluable knowledge and then apply it in a practical hands-on manner. I highly recommend going through the first two parts before diving into this guide: The R-CNN family of techniques we saw in Part 1 primarily use regions to localize the objects within the image. The network does not look at the entire image, only at the parts of the images which have a higher chance of containing an object. The YOLO framework (You Only Look Once) on the other hand, deals with object detection in a different way. It takes the entire image in a single instance and predicts the bounding box coordinates and class probabilities for these boxes. The biggest advantage of using YOLO is its superb speed <U+2013> it¡¯s incredibly fast and can process 45 frames per second. YOLO also understands generalized object representation. This is one of the best algorithms for object detection and has shown a comparatively similar performance to the R-CNN algorithms. In the upcoming sections, we will learn about different techniques used in YOLO algorithm. The following explanations are inspired by Andrew NG¡¯s course on Object Detection which helped me a lot in understanding the working of YOLO. Now that we have grasp on why YOLO is such a useful framework, let¡¯s jump into how it actually works. In this section, I have mentioned the steps followed by YOLO for detecting objects in a given image. Pretty straightforward, isn¡¯t it? Let¡¯s break down each step to get a more granular understanding of what we just learned. We need to pass the labelled data to the model in order to train it. Suppose we have divided the image into a grid of size 3 X 3 and there are a total of 3 classes which we want the objects to be classified into. Let¡¯s say the classes are Pedestrian, Car, and Motorcycle respectively. So, for each grid cell, the label y will be an eight dimensional vector: Here, Let¡¯s say we select the first grid from the above example: Since there is no object in this grid, pc will be zero and the y label for this grid will be: Here, ¡®?¡¯ means that it doesn¡¯t matter what bx, by, bh, bw, c1, c2, and c3<U+00A0>contain as there is no object in the grid. Let¡¯s take another grid in which we have a car (c2 = 1): Before we write the y label for this grid, it¡¯s important to first understand how YOLO decides whether there actually is an object in the grid. In the above image, there are two objects (two cars), so YOLO will take the mid-point of these two objects and these objects will be assigned to the grid which contains the mid-point of these objects. The y label for the centre left grid with the car will be: Since there is an object in this grid, pc<U+00A0>will be equal to 1. bx, by, bh, bw will be calculated relative to the particular grid cell we are dealing with. Since car is the second class, c2 = 1 and c1 and c3 = 0. So, for each of the 9 grids, we will have an eight dimensional output vector. This output will have a shape of 3 X 3 X 8. So now we have an input image and it¡¯s corresponding target vector. Using the above example (input image <U+2013> 100 X 100 X 3, output <U+2013> 3 X 3 X 8), our model will be trained as follows: We will run both forward and backward propagation to train our model. During the testing phase, we pass an image to the model and run forward propagation until we get an output y. In order to keep things simple, I have explained this using a 3 X 3 grid here, but generally in real-world scenarios we take larger grids (perhaps 19 X 19). Even if an object spans out to more than one grid, it will only be assigned to a single grid in which its mid-point is located. We can reduce the chances of multiple objects appearing in the same grid cell by increasing the more number of grids (19 X 19, for example). As I mentioned earlier, bx, by, bh, and bw are calculated relative to the grid cell we are dealing with. Let¡¯s understand this concept with an example. Consider the center-right grid which contains a car: So, bx, by, bh, and bw will be calculated relative to this grid only. The y label for this grid will be: pc = 1 since there is an object in this grid and since it is a car, c2 = 1. Now, let¡¯s see how to decide bx, by, bh, and bw. In YOLO, the coordinates assigned to all the grids are: bx, by are the x and y coordinates of the midpoint of the object with respect to this grid. In this case, it will be (around) bx = 0.4 and by = 0.3: bh<U+00A0>is the ratio of the height of the bounding box (red box in the above example) to the height of the corresponding grid cell, which in our case is around 0.9. So, <U+00A0>bh = 0.9. bw is the ratio of the width of the bounding box to the width of the grid cell. So, bw = 0.5 (approximately). The y label for this grid will be: Notice here that bx and by will always range between 0 and 1 as the midpoint will always lie within the grid. Whereas bh and bw can be more than 1 in case the dimensions of the bounding box are more than the dimension of the grid. In the next section, we will look at more ideas that can potentially help us in making this algorithm¡¯s performance even better. Here¡¯s some food for thought <U+2013> how can we decide whether the predicted bounding box is giving us a good outcome (or a bad one)? This is where Intersection over Union comes into the picture. It calculates the intersection over union of the actual bounding box and the predicted bonding box. Consider the actual and predicted bounding boxes for a car as shown below: Here, the red box is the actual bounding box and the blue box is the predicted one. How can we decide whether it is a good prediction or not? IoU, or Intersection over Union, will calculate the area of the intersection over union of these two boxes. That area will be: IoU = Area of the intersection / Area of the union, i.e. IoU = Area of yellow box / Area of green box If IoU is greater than 0.5, we can say that the prediction is good enough. 0.5 is an arbitrary threshold we have taken here, but it can be changed according to your specific problem. Intuitively, the more you increase the threshold, the better the predictions become. There is one more technique that can improve the output of YOLO significantly <U+2013> Non-Max Suppression. One of the most common problems with object detection algorithms is that rather than detecting an object just once, they might detect it multiple times. Consider the below image: Here, the cars are identified more than once. The Non-Max Suppression technique cleans up this up so that we get only a single detection per object. Let¡¯s see how this approach works. 1. It first looks at the probabilities associated with each detection and takes the largest one. In the above image, 0.9 is the highest probability, so the box with 0.9 probability will be selected first: 2. Now, it looks at all the other boxes in the image. The boxes which have high IoU with the current box are suppressed. So, the boxes with 0.6 and 0.7 probabilities will be suppressed in our example: 3. After the boxes have been suppressed, it selects the next box from all the boxes with the highest probability, which is 0.8 in our case: 4. Again it will look at the IoU of this box with the remaining boxes and compress the boxes with a high IoU: 5. We repeat these steps until all the boxes have either been selected or compressed and we get the final bounding boxes: This is what Non-Max Suppression is all about. We are taking the boxes with maximum probability and suppressing the close-by boxes with non-max probabilities. Let¡¯s quickly summarize the points which we¡¯ve seen in this section about the Non-Max suppression algorithm: There is another method we can use to improve the perform of a YOLO algorithm <U+2013> let¡¯s check it out! We have seen that each grid can only identify one object. But what if there are multiple objects in a single grid? That can so often be the case in reality. And that leads us to the concept of anchor boxes. Consider the following image, divided into a 3 X 3 grid: Remember how we assigned an object to a grid? We took the midpoint of the object and based on its location, assigned the object to the corresponding grid. In the above example, the midpoint of both the objects lies in the same grid. This is how the actual bounding boxes for the objects will be: We will only be getting one of the two boxes, either for the car or for the person. But if we use anchor boxes, we might be able to output both boxes! How do we go about doing this? First, we pre-define two different shapes called anchor boxes or anchor box shapes. Now, for each grid, instead of having one output, we will have two outputs. We can always increase the number of anchor boxes as well. I have taken two here to make the concept easy to understand: This is how the y label for YOLO without anchor boxes looks like: What do you think the y label will be if we have 2 anchor boxes? I want you to take a moment to ponder this before reading further. Got it? The y label will be: The first 8 rows belong to anchor box 1 and the remaining 8 belongs to anchor box 2. The objects are assigned to the anchor boxes based on the similarity of the bounding boxes and the anchor box shape. Since the shape of anchor box 1 is similar to the bounding box for the person, the latter will be assigned to anchor box 1 and the car will be assigned to anchor box 2. The output in this case, instead of 3 X 3 X 8 (using a 3 X 3 grid and 3 classes), will be 3 X 3 X 16 (since we are using 2 anchors). So, for each grid, we can detect two or more objects based on the number of anchors. Let¡¯s combine all the ideas we have covered so far and integrate them into the YOLO framework. In this section, we will first see how a YOLO model is trained and then how the predictions can be made for a new and previously unseen image. Training The input for training our model will obviously be images and their corresponding y labels. Let¡¯s see an image and make its y label: Consider the scenario where we are using a 3 X 3 grid with two anchors per grid, and there are 3 different object classes. So the corresponding y labels will have a shape of 3 X 3 X 16. Now, suppose if we use 5 anchor boxes per grid and the number of classes has been increased to 5. So the target will be 3 X 3 X 5 X 5 = 3 X 3 X 25. This is how the training process is done <U+2013> taking an image of a particular shape and mapping it with a 3 X 3 X 16 target (this may change as per the grid size, number of anchor boxes and the number of classes). Testing The new image will be divided into the same number of grids which we have chosen during the training period. For each grid, the model will predict an output of shape 3 X 3 X 16 (assuming this is the shape of the target during training time). The 16 values in this prediction will be in the same format as that of the training label. The first 8 values will correspond to anchor box 1, where the first value will be the probability of an object in that grid. Values 2-5 will be the bounding box coordinates for that object, and the last three values will tell us which class the object belongs to. The next 8 values will be for anchor box 2 and in the same format, i.e., first the probability, then the bounding box coordinates, and finally the classes. Finally, the Non-Max Suppression technique will be applied on the predicted boxes to obtain a single prediction per object. That brings us to the end of the theoretical aspect of understanding how the YOLO algorithm works, starting from training the model and then generating prediction boxes for the objects. Below are the exact dimensions and steps that the YOLO algorithm follows: Time to fire up our Jupyter notebooks (or your preferred IDE) and finally implement our learning in the form of code! This is what we have been building up to so far, so let¡¯s get the ball rolling. The code we¡¯ll see in this section for implementing YOLO has been taken from Andrew NG¡¯s GitHub repository on Deep Learning. You will also need to download this zip file which contains the pretrained weights required to run this code. Let¡¯s first define the functions that will help us choose the boxes above a certain threshold, find the IoU, and apply Non-Max Suppression on them. Before everything else however, we¡¯ll first import the required libraries: Now, let¡¯s create a function for filtering the boxes based on their probabilities and threshold: Next, we will define a function to calculate the IoU between two boxes: Let¡¯s define a function for Non-Max Suppression: We now have the functions that will calculate the IoU and perform Non-Max Suppression. We get the output from the CNN of shape (19,19,5,85). So, we will create a random volume of shape (19,19,5,85) and then predict the bounding boxes: Finally, we will define a function which will take the outputs of a CNN as input and return the suppressed boxes: Let¡¯s see how we can use the yolo_eval function to make predictions for a random volume which we created above: How does the outlook look? ¡®scores¡¯ represents how likely the object will be present in the volume. ¡®boxes¡¯ returns the (x1, y1, x2, y2) coordinates for the detected objects. ¡®classes¡¯ is the class of the identified object. Now, let¡¯s use a pretrained YOLO algorithm on new images and see how it works: After loading the classes and the pretrained model, let¡¯s use the functions defined above to get the yolo_outputs. Now, we will define a function to predict the bounding boxes and save the images with these bounding boxes included: Next, we will read an image and make predictions using the predict function: Finally, let¡¯s plot the predictions: Not bad! I especially like that the model correctly picked up the person in the mini-van as well. Here¡¯s a brief summary of what we covered and implemented in this guide: YOLO is one of my all-time favorite frameworks and I¡¯m sure you¡¯ll see why once you implement the code on your own machine. It¡¯s a great way of getting your hands dirty with a popular computer vision algorithm. If you have any questions or feedback regarding this guide, connect with me in the comments section below. Thanks for article.
How does YOLO compare with Faster-RCNN for detection of very small objects like scratches on metal surface? My observation was <U+2013> RCNN lacks an elegant way to compute anchor sizes based on dataset¡¦ also I attempted changing scales,strides,box size results are bad.
How do we custom train for YOLO? Hi, YOLO is faster in comparison to Faster-RCNN. Their accuracies are comparatively similar. YOLO does not work pretty well for small objects.
In order to improve its performance on smaller objects, you can try the following things: This may give better results. Is this Yolo implemented on GPU based?
How to training Yolo for customize object?
Is are sany yolo code or tutorial using Tensorflow GPU base is available ?
I only want to did detect vehicles.
Please guide me."
"vidhya",2018-12-03,"5 Best Machine Learning GitHub Repositories & Reddit Discussions (November 2018)","https://www.analyticsvidhya.com/blog/2018/12/best-machine-learning-github-repositories-reddit-threads-november-2018/","Coding is among one of the best things about being a data scientist. There are often days when I find myself immersed in programming something from scratch. That exhilarating feeling you get when you see your hard work culminate in a successful model? Exhilarating and unparalleled! But as a data scientist (or a programmer), its equally important to create checkpoints of your code at various intervals. It¡¯s incredibly helpful to know where you started off from last time so if you have to rollback your code or simply branch out to a different path, there¡¯s always a fallback option. And that¡¯s why GitHub is such an excellent platform. The previous posts in this monthly series have expounded on why every data scientist should have an active GitHub account. Whether it¡¯s for collaboration, resume/portfolio, or educational purposes, it¡¯s simply the best place to enhance your coding skills and knowledge. And now let¡¯s get to the core of our article <U+2013> machine learning code! I have picked out some really interesting repositories which I feel every data scientist should try out on their own. Apart from coding, there are tons of aspects associated with being a data scientist. We need to be aware of all the latest developments in the community, what other machine learning professionals and thought leaders are talking about, what are the moral implications of working on a controversial project, etc. That is what I aim to bring out in the Reddit discussion threads I showcase every month. To make things easier for you, here¡¯s the entire collection so far of the top GitHub repositories and Reddit discussions (from April onwards) we have covered each month: Keeping our run going of including reinforcement learning resources in this series, here¡¯s one of the best so far <U+2013> OpenAI¡¯s Spinning Up! This is an educational resource open sourced with the aim of making it easier to learn deep RL. Given how complex it can appear to most folks, this is quite a welcome repository. The repo contains a few handy resources: This one is for all the audio/speech processing people out there. WaveGlow is a flow-based generative network for speech synthesis. In other words, it¡¯s a network (yes, a single network!) that can generate impressive high quality speech from<U+00A0>mel-spectrograms. This repo contains the PyTorch implementation of WaveGlow and a pre-trained model to get you started. It¡¯s a really cool framework, and you can check out the below links as well if you wish to delve deeper: We covered the PyTorch implmentation of BERT in last month¡¯s article, and here¡¯s a different take on it. For those who are new to BERT, it stands for<U+00A0>Bidirectional<U+00A0>Encoder<U+00A0>Representations from<U+00A0>Transformers. It¡¯s basically a method for pre-training language representations. BERT has set the NLP world ablaze with it¡¯s results, and the folks at Google have been kind enough to release quite a few pre-trained models to get you on your way. This repository ¡°uses BERT as the sentence encoder and hosts it as a service via ZeroMQ, allowing you to map sentences into fixed-length representations in just two lines of code¡±. It¡¯s easy to use, extremely quick, and scales smoothly. Try it out! Quick, Draw is a popular online game developed by Google where a neural network tries to guess what you¡¯re drawing. The neural network learns from each drawing, hence increasing it¡¯s already impressive ability to correctly guess the doodle. The developers have built up a HUGE dataset from the amount of drawings users have made previously. It¡¯s an open-source dataset which you can check out here. And now you can build your own Quick, Draw game in Python with this repository. There is a step-by-step explanation of how to do this. Using this code, you can run an app to either draw in front of the computer¡¯s webcam, or on a canvas. GAN Dissection, pioneered by researchers at MIT¡¯s<U+00A0>Computer Science & Artificial Intelligence Laboratory, is a unique way of visualizing and understanding the neurons of Generative Adversarial Networks (GANs). But it isn¡¯t just limited to that <U+2013> the researchers have also created GANPaint<U+00A0>to showcase how GAN Dissection works. This helps you explore what a particular GAN model has learned by inspecting and manipulating it¡¯s internal neurons. Check out the research paper here and the below video demo, and then head straight to the GitHub repository to dive straight into the code! Has this question ever crossed your mind while learning basic machine learning concepts? This is one of the fundamental algorithms we come across in our initial learning days and has proven to be quite effective in ML competitions as well. But once you start going through this thread, prepare to seriously question what you¡¯ve studied previously. What started off as a straight forward question turned into a full-blown discussion among the top minds on Reddit. I thoroughly enjoyed browsing through the comments and I¡¯m sure anyone with interest in this field (and mathematical rigour) will find it useful. What do you do when the developer of a complex and massive neural network vanishes without leaving behind the documentation needed to understand it? This isn¡¯t a fictional plot, but a rather common situation the original poster of the thread found himself in. It¡¯s a situation that happens regularly with developers but takes on a whole new level of intrigue when it comes to deep learning. This thread explores the different ways a data scientist can go about examining how a deep neural network model was initially designed. The responses range from practical to absurd, but each adds a layer of perspective which could help you one day if you ever face this predicament. My attention to this thread was drawn by the sheer number of comments (110 at the time of writing) <U+2013> what in the world could be so controversial about this topic? But when you started scrolling down, the sheer difference in opinions among the debators is mind boggling. Apart from TensorFlow being derided for being ¡°not the best framework¡±, there¡¯s a lot of love being shown to PyTorch (which isn¡¯t all that surprising if you¡¯ve used PyTorch). It all started when Francois Chollet posted his thoughts on GitHub and lit a (metaphorical) fire under the machine learning community. Another OpenAI entry in this post <U+2013> and yet another huge breakthrough by them. The title might not leap out of the page as anything special but it¡¯s important to understand what the OpenAI team have conjured up here. As one of the Redditors pointed out, this takes us one step closer to machines mimicking human behavior. It took around a year of total experience to beat the Montezuma¡¯s Revenge game at a super human level <U+2013> pretty impressive! This one is for all the aspiring data scientists reading the article. The author of the thread expounds on how he landed the coveted job, his background, where he studied data science from, etc. After answering these standard questions, he has actually written a very nice post on what others in a similar position can do to further their ambitions. There are some helpful comments as well if you scroll down a little bit. And of course, you can post your own question(s) to the author there. Quite a collection this month. I found the GAN Dissection repository quite absorbing. I¡¯m currently in the process of trying to replicate it on my own machine <U+2013> should be quite the ride. I¡¯m also keeping an eye on the ¡®Reverse Engineering a Massive Neural Network¡¯ thread as the ideas spawning there could be really helpful in case I ever find myself in that situation. Which GitHub repository and Reddit thread stood out for you? Which one will you tackle first? Let me know in the comments section below!"
"vidhya",2018-12-03,"Building a Random Forest from Scratch & Understanding Real-World Data Products (ML for Programmers <U+2013> Part 3)","https://www.analyticsvidhya.com/blog/2018/12/building-a-random-forest-from-scratch-understanding-real-world-data-products-ml-for-programmers-part-3/","As data scientists and machine learning practitioners, we come across and learn a plethora of algorithms. Have you ever wondered where each algorithm¡¯s true usefulness lies? Are most machine learning techniques learned with the primary aim of scaling a hackathon¡¯s leaderboard? Not necessarily. It¡¯s important to examine and understand where and how machine learning is used in real-world industry scenarios. That¡¯s where most of us are working (or will eventually work). And that¡¯s what I aim to show in this part 3 of our popular series covering the fast.ai introduction to machine learning course! We covered a fairly comprehensive introduction to random forests in part 1 using the fastai library, and followed that up with a very interesting look at how to interpret a random forest model. The latter part is especially quite relevant and important to grasp in today¡¯s world. In this article, we will first take a step back and analyze machine learning from a business standpoint. Then we¡¯ll jump straight back to where we left off part 2 <U+2013> building a random forest model from scratch. I encourage you to hop back to the previous posts in case you need to refresh any concept, and carry that learning with you as we move forward. Having learned the basic underlying concept of a random forest model and the techniques used to interpret the results, the obvious follow-up question to ask is <U+2013> where are these models and interpretation techniques used in real life? It¡¯s all well and good knowing the technique, but if we don¡¯t know where and when to apply it, it feels like a wasted effort. Jeremy Howard answers this question in Lesson #6, where he explains how a random forest model can be used to interpret and understand the data. This lesson is also a walkthrough covering all the techniques we have learned in the previous two articles. In this section, we will look at various sectors where machine learning has already made it¡¯s presence felt and is being implemented successfully. The business market, as explained by Jeremy, can broadly be divided into two groups <U+2013> horizontal and vertical. We will look at these individually, but first, let¡¯s understand the most important steps involved in designing a machine learning model. There are broadly four steps we follow for doing this. These collectively form the ¡°drivetrain approach¡±, as explained by Jeremy in his paper:<U+00A0>Designing Great Data Products. Step 1: Define the Objective Before diving into the challenge and building a machine learning model, one must have a clear, well-defined objective or an end goal in mind. This may vary depending on what the organization is trying to achieve. A couple of examples are given below: Step 2: Levers Levers are the inputs that can be controlled, or some changes the organization can make, to drive the objective defined in step 1. For instance, to ensure that the customers are satisfied: A machine learning model cannot be a lever, but it can help the organization identify the levers. It¡¯s important to understand this distinction clearly. Step 3: Data  The next step is to find out what data can be helpful in identifying and setting the lever that the organization may have (or can collect). This can be different from the data already provided or collected by the organization earlier. Step 4: Predictive models Once we have the required data that can be helpful in achieving the above defined goal, the last step is to build a simulation model on this data. Note that a simulation model can have multiple predictive models. For example, building one model identifying what items should be recommended to a user, and another model predicting the probability that a user buys a particular product on a recommendation. The idea is to create an optimization model, rather than a predictive model. You can read the paper I linked above to understand these steps in more detail. We¡¯ll move on to understand the applications of machine learning from the industry and business point-of-view. As we alluded to earlier, we can divide the business market broadly into two groups <U+2013> horizontal and vertical. I will elaborate on each in this section to give you an industry-level perspective on things. Horizontal markets are usually defined by demography (can be common across different kinds of business), which is broadly everything involving marketing. Here is a group of marketing applications where machine learning can (and is) be used. Taking the example of ¡®Churn¡¯, the goal is to determine who is going to leave or attrite. Suppose an organization has a churn model that predicts which employee is going to leave and what can be changed so that the number of employees leaving is reduced. Once the end goal is defined, we can make a list of things that can be changed in order to decrease the number of people who are leaving the organization and collect whatever data we need to build a model. Then we can create a random forest model and use the interpretation techniques we learned previously. For instance, the feature importance aspect from the random forest model can help us understand which features matter the most. Or the pdp plot visualization can be useful in determining how a particular change will affect the target variable (aka probability of an employee attriting). Vertical market refers to a group of businesses sharing the same industry, such as education, healthcare, aerospace, finance, etc. Below are a couple of examples where machine learning is being used in such cases: It¡¯s a good exercise to discuss the applications of machine learning in various domains and answer the following questions for each: Our discussion so far would have given you a fair idea about the plethora of machine learning applications in the industry. We¡¯ll do a quick review of the random forest interpretation techniques and then continue building the random forest model from scratch after that. We¡¯ll quickly recap these techniques since we have covered them in part 2. For a more detailed explanation, you can take a look at this article: Standard deviation We calculated the standard deviation of the predictions (for each level in Enclosure and ProductSize) to figure out which categories are being wrongly predicted by the model and why. We found that for categories with a low value count, the model is giving a high standard deviation. So there are higher chances that the predictions for categories with a larger value count are more accurate (since the model is trained well for these categories). Makes sense, right? Feature Importance Feature importance is basically determining how important a feature is in predicting the target variable. The top 30 variables for the random forest model are the following: As it is evident from the above plot, YearMade is the most important variable. This makes sense because the older the vehicle, the lesser the saleprice. The model performance improved when the less important features were removed from the training set. This, as you can imagine, can be really helpful in understanding the data and variables. Additionally, we can use one-hot encoding to create columns for each level and then calculate the feature importance: Partial Dependence Plot (PDP) Partial dependence is used to understand the dependence of features on the target variable. This is done by predicting the target for each row, keeping a variable constant. For instance, predicting saleprice for each row when YearMade is 1960, then for YearMade 1961, and so on. The result would be a plot like this: Tree Interpreter The tree interpreter is used to evaluate the predictions for each row using all the trees in the random forest model. This also helps us understand how much each variable contributed to the final prediction. Before we understand how the contribution for multiple trees is calculated, let¡¯s take a look at a single tree: The value of Coupler_System<=5 is 10.189, for Enclosure<=2 is 2.0, and model_id comes out to be 9.955 (considering only the top most path for now). The value for Enclosure <=2 is not only because of the feature Enclosure, but a combination of Coupler_System and Enclosure. In other words, we can say that Coupler_System interacted with Enclosure with a contribution of 0.156. Similarly, we can determine the interaction importance between features. Now we can use the average of all the trees in order to calculate the overall contribution by each feature. For the first row in the validation set, below are the contributions by each variable: Just a reminder that the calculation behind the values generated has been covered in the previous post. Extrapolation For this particular topic, Jeremy performs live coding during the lecture by creating a synthetic dataset using linespace. We have set the start and end points as 0 and 1. The next step is to create a dependent variable. For simplicity, we assume a linear relationship between x and y. We can use the following code to generate our target variable and plot the same: We¡¯ll convert our 1D array into a 2D array which will be used as an input to the random forest model. Out of the 50 data points, we¡¯ll take 40 for training our random forest model and keep the remaining 10 to be used as the validation set. We can now fit a random forest model and compare the predictions against actual values. The results are pretty good, but do you think we¡¯ll get similar results on the validation set? We have trained our model on the first 40 data points, the scale of which is actually very different from that of the validation set. So any new point that the random forest model tries to predict, it inevitably identifies that these points are closer to the highest of the given 40 points. Lets have a look at the plot: This confirms our hunch that random forest cannot extrapolate to a type of data that it has never seen before. It¡¯ll basically give you the average of the data it has previously seen. So how should one deal with this type of data? We can potentially use neural nets which have proved to work better with such cases. Another obvious solution is to use time series techniques (which i have personnaly worked on and can confirm that they show far better results). So to conclude lesson #6, we covered the necessary steps involved in building a machine learning model and briefly looked at all the interpretation techniques we learned in the previous article. If you have any questions on this section, please let me know in the comments below the article. We started learning how to build a random forest model from scratch in the previous article. We¡¯ll take it up from where we left off in this section (lesson #7). By the end of this lesson, you¡¯ll be able to build an end-to-end random forest model from the ground up on your own. Sounds pretty exciting so let¡¯s continue! We have discussed the random forest algorithm in detail <U+2013> from understanding how it works to how the split points are selected, and how the predictions are calculated. We are now going to put our understanding into code form, one step at a time, i.e., creating a model that works with few features, smaller number of trees, and a subset of the data. Note: Steps 1 to 6 have been covered in the previous article. Step 1:<U+00A0>Importing the basic libraries. Step 2:<U+00A0>Read the data and split into train and validation sets. Step 3:<U+00A0>Take a subset of data to start with. As I previously mentioned, we¡¯ll take smaller steps, so here we pick only two features and work with them. If that works well, we can complete the model by taking all the features. Step 4:<U+00A0>Define the set of inputs: Step 5:<U+00A0>Define a function that uses a sample of data (with replacement) and creates a decision tree over the same. Step 6:<U+00A0>Create a predict function. The mean of the predicted value from each tree for a particular row is returned as the final prediction. Combining all the above functions, we can create a class TreeEnsemble. Step 7:<U+00A0>Create a class DecisionTree. We call DecisionTree in the function create_tree, so let¡¯s define it here. A decision tree would have a set of independent variables, a target variable, and the index values. For now, we have created only one decision tree (we can make it recursive later). Step 8:<U+00A0>Determine the best split point. For every column, we use the function find_better_split<U+00A0>to identify a split point and then return the column name, value, and score for the split. Step 9:<U+00A0>Build our first model with 10 trees, a sample size of 1,000 and minimum leaf as 3. For the first tree, the results are: Let¡¯s now fill the block that we left above in Step 8 <U+2013> find_better_split. This is by far the most complicated part of the code to understand, but Jeremy has explained using a simple example in excel. I will explain it in an intuitive manner here. For each variable, we split the points to the left and right node, and check the score for every value. The idea is to find a split point where we are able to separate more similar points together. Consider the following example: we have two columns <U+2013> an independent variable which we try to split on, and a binary target variable. We will split at each value of the first column and calculate a standard deviation to identify how well we were able to classify the target. Let¡¯s suppose the first split point is >=3, and then calculate the standard deviation. We can take a weighted average of this value. Similarly, we can calculate for a split at 4, 6, 1 and so on. Let¡¯s put this into code: If we try to print the results of the function for both the columns individually, we get the below result: Looks like YearMade 1974 is a better split point. Step 10:<U+00A0>Compare with the scikit-learn random forest. But keep in mind that there¡¯s a tricky aspect here. While comparing the two models, both of them should have the same input. So let¡¯s store the input that we have used in the random forest we just built. And now we build a model on this subset: We see that the split here is on the column YearMade at year 1974.5, very similar to the results of our model. Not bad! Step 11:<U+00A0>There¡¯s a problem with the code we have seen so far <U+2013> can you recognize what it is? We need to optimise it!<U+00A0>in the current format, we are checking the score for the split at each row, aka we are checking for a single value multiple times. Have a look at the example we used earlier: The function will check the split points 4 and 1 twice because it actually works row-wise. It¡¯s a good idea to optimise our code so as to reduce the computation time (not everyone has a top machine!). The idea is to sort column-wise and then check the score after the split for unique values only. Also, to calculate the standard deviation, we define the following function: We will need to keep a track of the count of data points on each side of the split along with the sum of square of the values. So we initialize the variables rhs_cnt, lhs_cnt, rjs_sum2 and lhs_sum2.  Adding all this up, the code looks like this: Ideally, this function should give the same results. Let¡¯s check: Note that we created a new function (slightly changed the name from find_better_split to find_better_split_foo), and we need to use this in our DecisionTree class. The following command does it for us: Step 12:<U+00A0>Build our tree with more than one split. In step 10, we compared the first level of our model with the scikit-learn random forest model. We will now create a full tree (which splits on both our features) and compare it again. Right now our find_varsplit function looks like this: where we have defined find_better_split separately. We will update this function, so that it automatically checks for the leaf node and stores a list of indices in lhs and rhs after the split. We will again compare both the models. Previously, the max_depth was restricted to 1, and we will make it 2 here (we have only two features for now): And now look at our results: According to the image above, lhs should have 159 samples and a value of 9.66, while rhs should have 841 samples and a value of 10.15. Everything looks perfect so far! Going one level deeper into the tree, the left side of lhs should consist of 150 samples: Great! We are able to build our own tree. Let¡¯s create a function to calculate the predictions and then we¡¯ll compare the r-square values. Step 13:<U+00A0>Calculate the final predictions. We have called a predict function in TreeEnsemble<U+00A0>that returns the prediction for each row: With this, we have completed building our own random forest model. Let¡¯s plot the predictions on the validation set: Checking the performance and r-square against the scikit-learn model: Step 14:<U+00A0>Putting it all together! And there you go! That was quite a learning experience and we have now officially built a machine learning technique right from scratch. Something to be truly proud of! Let¡¯s quickly recap what we covered in part 3. We started with Lesson 6 which broadly covers the applications of machine learning in various business domains and a revision of the interpretation techniques we saw in part 2. The second half of this article covered<U+00A0>Lesson 7 and was a bit code heavy. We built a complete random forest model and compared it¡¯s performance against the scikit-learn¡¯s model. It is a good practice to understand how the model actually works, instead of simply implementing the model. With this, we come to the end of understanding, interpreting and building a random forest model. In the next part, we will shift our focus to neural networks. We¡¯ll be working on the very popular MNIST dataset so that should be quite fun! Nice article, Thanks Aishwarya !"
"vidhya",2018-12-06,"A Practical Guide to Object Detection using the Popular YOLO Framework <U+2013> Part III (with Python codes) ","https://www.analyticsvidhya.com/blog/2018/12/practical-guide-object-detection-yolo-framewor-python/","How easy would our life be if we simply took an already designed framework, executed it, and got the desired result? Minimum effort, maximum reward. Isn¡¯t that what we strive for in any profession? I feel incredibly lucky to be part of our machine learning community where even the top tech behemoths embrace open source technology. Of course it¡¯s important to understand and grasp concepts before implementing them, but it¡¯s always helpful when the ground work has been laid for you by top industry data scientists and researchers. This is especially true for deep learning domains like computer vision. Not everyone has the computational resources to build a DL model from scratch. That¡¯s where predefined frameworks and pretained models come in handy. And in this article, we will look at one such framework for object detection <U+2013> YOLO. It¡¯s a supremely fast and accurate framework, as we¡¯ll see soon. So far in our series of posts detailing object detection (links below), we¡¯ve seen the various algorithms that are used, and how we can detect objects in an image and predict bounding boxes using algorithms of the R-CNN family. We have also looked at the implementation of Faster-RCNN in Python. In part 3 here, we will learn what makes YOLO tick, why you should use it over other object detection algorithms, and the different techniques used by YOLO. Once we have understood the concept thoroughly, we will then implement it it in Python. It¡¯s the ideal guide to gain invaluable knowledge and then apply it in a practical hands-on manner. I highly recommend going through the first two parts before diving into this guide: The R-CNN family of techniques we saw in Part 1 primarily use regions to localize the objects within the image. The network does not look at the entire image, only at the parts of the images which have a higher chance of containing an object. The YOLO framework (You Only Look Once) on the other hand, deals with object detection in a different way. It takes the entire image in a single instance and predicts the bounding box coordinates and class probabilities for these boxes. The biggest advantage of using YOLO is its superb speed <U+2013> it¡¯s incredibly fast and can process 45 frames per second. YOLO also understands generalized object representation. This is one of the best algorithms for object detection and has shown a comparatively similar performance to the R-CNN algorithms. In the upcoming sections, we will learn about different techniques used in YOLO algorithm. The following explanations are inspired by Andrew NG¡¯s course on Object Detection which helped me a lot in understanding the working of YOLO. Now that we have grasp on why YOLO is such a useful framework, let¡¯s jump into how it actually works. In this section, I have mentioned the steps followed by YOLO for detecting objects in a given image. Pretty straightforward, isn¡¯t it? Let¡¯s break down each step to get a more granular understanding of what we just learned. We need to pass the labelled data to the model in order to train it. Suppose we have divided the image into a grid of size 3 X 3 and there are a total of 3 classes which we want the objects to be classified into. Let¡¯s say the classes are Pedestrian, Car, and Motorcycle respectively. So, for each grid cell, the label y will be an eight dimensional vector: Here, Let¡¯s say we select the first grid from the above example: Since there is no object in this grid, pc will be zero and the y label for this grid will be: Here, ¡®?¡¯ means that it doesn¡¯t matter what bx, by, bh, bw, c1, c2, and c3<U+00A0>contain as there is no object in the grid. Let¡¯s take another grid in which we have a car (c2 = 1): Before we write the y label for this grid, it¡¯s important to first understand how YOLO decides whether there actually is an object in the grid. In the above image, there are two objects (two cars), so YOLO will take the mid-point of these two objects and these objects will be assigned to the grid which contains the mid-point of these objects. The y label for the centre left grid with the car will be: Since there is an object in this grid, pc<U+00A0>will be equal to 1. bx, by, bh, bw will be calculated relative to the particular grid cell we are dealing with. Since car is the second class, c2 = 1 and c1 and c3 = 0. So, for each of the 9 grids, we will have an eight dimensional output vector. This output will have a shape of 3 X 3 X 8. So now we have an input image and it¡¯s corresponding target vector. Using the above example (input image <U+2013> 100 X 100 X 3, output <U+2013> 3 X 3 X 8), our model will be trained as follows: We will run both forward and backward propagation to train our model. During the testing phase, we pass an image to the model and run forward propagation until we get an output y. In order to keep things simple, I have explained this using a 3 X 3 grid here, but generally in real-world scenarios we take larger grids (perhaps 19 X 19). Even if an object spans out to more than one grid, it will only be assigned to a single grid in which its mid-point is located. We can reduce the chances of multiple objects appearing in the same grid cell by increasing the more number of grids (19 X 19, for example). As I mentioned earlier, bx, by, bh, and bw are calculated relative to the grid cell we are dealing with. Let¡¯s understand this concept with an example. Consider the center-right grid which contains a car: So, bx, by, bh, and bw will be calculated relative to this grid only. The y label for this grid will be: pc = 1 since there is an object in this grid and since it is a car, c2 = 1. Now, let¡¯s see how to decide bx, by, bh, and bw. In YOLO, the coordinates assigned to all the grids are: bx, by are the x and y coordinates of the midpoint of the object with respect to this grid. In this case, it will be (around) bx = 0.4 and by = 0.3: bh<U+00A0>is the ratio of the height of the bounding box (red box in the above example) to the height of the corresponding grid cell, which in our case is around 0.9. So, <U+00A0>bh = 0.9. bw is the ratio of the width of the bounding box to the width of the grid cell. So, bw = 0.5 (approximately). The y label for this grid will be: Notice here that bx and by will always range between 0 and 1 as the midpoint will always lie within the grid. Whereas bh and bw can be more than 1 in case the dimensions of the bounding box are more than the dimension of the grid. In the next section, we will look at more ideas that can potentially help us in making this algorithm¡¯s performance even better. Here¡¯s some food for thought <U+2013> how can we decide whether the predicted bounding box is giving us a good outcome (or a bad one)? This is where Intersection over Union comes into the picture. It calculates the intersection over union of the actual bounding box and the predicted bonding box. Consider the actual and predicted bounding boxes for a car as shown below: Here, the red box is the actual bounding box and the blue box is the predicted one. How can we decide whether it is a good prediction or not? IoU, or Intersection over Union, will calculate the area of the intersection over union of these two boxes. That area will be: IoU = Area of the intersection / Area of the union, i.e. IoU = Area of yellow box / Area of green box If IoU is greater than 0.5, we can say that the prediction is good enough. 0.5 is an arbitrary threshold we have taken here, but it can be changed according to your specific problem. Intuitively, the more you increase the threshold, the better the predictions become. There is one more technique that can improve the output of YOLO significantly <U+2013> Non-Max Suppression. One of the most common problems with object detection algorithms is that rather than detecting an object just once, they might detect it multiple times. Consider the below image: Here, the cars are identified more than once. The Non-Max Suppression technique cleans up this up so that we get only a single detection per object. Let¡¯s see how this approach works. 1. It first looks at the probabilities associated with each detection and takes the largest one. In the above image, 0.9 is the highest probability, so the box with 0.9 probability will be selected first: 2. Now, it looks at all the other boxes in the image. The boxes which have high IoU with the current box are suppressed. So, the boxes with 0.6 and 0.7 probabilities will be suppressed in our example: 3. After the boxes have been suppressed, it selects the next box from all the boxes with the highest probability, which is 0.8 in our case: 4. Again it will look at the IoU of this box with the remaining boxes and compress the boxes with a high IoU: 5. We repeat these steps until all the boxes have either been selected or compressed and we get the final bounding boxes: This is what Non-Max Suppression is all about. We are taking the boxes with maximum probability and suppressing the close-by boxes with non-max probabilities. Let¡¯s quickly summarize the points which we¡¯ve seen in this section about the Non-Max suppression algorithm: There is another method we can use to improve the perform of a YOLO algorithm <U+2013> let¡¯s check it out! We have seen that each grid can only identify one object. But what if there are multiple objects in a single grid? That can so often be the case in reality. And that leads us to the concept of anchor boxes. Consider the following image, divided into a 3 X 3 grid: Remember how we assigned an object to a grid? We took the midpoint of the object and based on its location, assigned the object to the corresponding grid. In the above example, the midpoint of both the objects lies in the same grid. This is how the actual bounding boxes for the objects will be: We will only be getting one of the two boxes, either for the car or for the person. But if we use anchor boxes, we might be able to output both boxes! How do we go about doing this? First, we pre-define two different shapes called anchor boxes or anchor box shapes. Now, for each grid, instead of having one output, we will have two outputs. We can always increase the number of anchor boxes as well. I have taken two here to make the concept easy to understand: This is how the y label for YOLO without anchor boxes looks like: What do you think the y label will be if we have 2 anchor boxes? I want you to take a moment to ponder this before reading further. Got it? The y label will be: The first 8 rows belong to anchor box 1 and the remaining 8 belongs to anchor box 2. The objects are assigned to the anchor boxes based on the similarity of the bounding boxes and the anchor box shape. Since the shape of anchor box 1 is similar to the bounding box for the person, the latter will be assigned to anchor box 1 and the car will be assigned to anchor box 2. The output in this case, instead of 3 X 3 X 8 (using a 3 X 3 grid and 3 classes), will be 3 X 3 X 16 (since we are using 2 anchors). So, for each grid, we can detect two or more objects based on the number of anchors. Let¡¯s combine all the ideas we have covered so far and integrate them into the YOLO framework. In this section, we will first see how a YOLO model is trained and then how the predictions can be made for a new and previously unseen image. Training The input for training our model will obviously be images and their corresponding y labels. Let¡¯s see an image and make its y label: Consider the scenario where we are using a 3 X 3 grid with two anchors per grid, and there are 3 different object classes. So the corresponding y labels will have a shape of 3 X 3 X 16. Now, suppose if we use 5 anchor boxes per grid and the number of classes has been increased to 5. So the target will be 3 X 3 X 5 X 5 = 3 X 3 X 25. This is how the training process is done <U+2013> taking an image of a particular shape and mapping it with a 3 X 3 X 16 target (this may change as per the grid size, number of anchor boxes and the number of classes). Testing The new image will be divided into the same number of grids which we have chosen during the training period. For each grid, the model will predict an output of shape 3 X 3 X 16 (assuming this is the shape of the target during training time). The 16 values in this prediction will be in the same format as that of the training label. The first 8 values will correspond to anchor box 1, where the first value will be the probability of an object in that grid. Values 2-5 will be the bounding box coordinates for that object, and the last three values will tell us which class the object belongs to. The next 8 values will be for anchor box 2 and in the same format, i.e., first the probability, then the bounding box coordinates, and finally the classes. Finally, the Non-Max Suppression technique will be applied on the predicted boxes to obtain a single prediction per object. That brings us to the end of the theoretical aspect of understanding how the YOLO algorithm works, starting from training the model and then generating prediction boxes for the objects. Below are the exact dimensions and steps that the YOLO algorithm follows: Time to fire up our Jupyter notebooks (or your preferred IDE) and finally implement our learning in the form of code! This is what we have been building up to so far, so let¡¯s get the ball rolling. The code we¡¯ll see in this section for implementing YOLO has been taken from Andrew NG¡¯s GitHub repository on Deep Learning. You will also need to download this zip file which contains the pretrained weights required to run this code. Let¡¯s first define the functions that will help us choose the boxes above a certain threshold, find the IoU, and apply Non-Max Suppression on them. Before everything else however, we¡¯ll first import the required libraries: Now, let¡¯s create a function for filtering the boxes based on their probabilities and threshold: Next, we will define a function to calculate the IoU between two boxes: Let¡¯s define a function for Non-Max Suppression: We now have the functions that will calculate the IoU and perform Non-Max Suppression. We get the output from the CNN of shape (19,19,5,85). So, we will create a random volume of shape (19,19,5,85) and then predict the bounding boxes: Finally, we will define a function which will take the outputs of a CNN as input and return the suppressed boxes: Let¡¯s see how we can use the yolo_eval function to make predictions for a random volume which we created above: How does the outlook look? ¡®scores¡¯ represents how likely the object will be present in the volume. ¡®boxes¡¯ returns the (x1, y1, x2, y2) coordinates for the detected objects. ¡®classes¡¯ is the class of the identified object. Now, let¡¯s use a pretrained YOLO algorithm on new images and see how it works: After loading the classes and the pretrained model, let¡¯s use the functions defined above to get the yolo_outputs. Now, we will define a function to predict the bounding boxes and save the images with these bounding boxes included: Next, we will read an image and make predictions using the predict function: Finally, let¡¯s plot the predictions: Not bad! I especially like that the model correctly picked up the person in the mini-van as well. Here¡¯s a brief summary of what we covered and implemented in this guide: YOLO is one of my all-time favorite frameworks and I¡¯m sure you¡¯ll see why once you implement the code on your own machine. It¡¯s a great way of getting your hands dirty with a popular computer vision algorithm. If you have any questions or feedback regarding this guide, connect with me in the comments section below. Thanks for article.
How does YOLO compare with Faster-RCNN for detection of very small objects like scratches on metal surface? My observation was <U+2013> RCNN lacks an elegant way to compute anchor sizes based on dataset¡¦ also I attempted changing scales,strides,box size results are bad.
How do we custom train for YOLO? Hi, YOLO is faster in comparison to Faster-RCNN. Their accuracies are comparatively similar. YOLO does not work pretty well for small objects.
In order to improve its performance on smaller objects, you can try the following things: This may give better results. Is this Yolo implemented on GPU based?
How to training Yolo for customize object?
Is are sany yolo code or tutorial using Tensorflow GPU base is available ?
I only want to did detect vehicles.
Please guide me."
