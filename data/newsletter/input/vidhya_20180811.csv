"site","date","headline","url_address","text"
"vidhya",2018-08-11,"Independence Day Bonanza with Analytics Vidhya¡¯s Offers and Launches!","https://www.analyticsvidhya.com/blog/2018/08/independence-day-bonanza-analytics-vidhyas-offers-launches/","

INDEPENDENCE DAY SALE: Get FLAT 60% OFF on All Courses | Use COUPON CODE: IDAY60 |
OFFER ENDS: 15th Aug 23:59 hrs IST | 
Valid for first 60 users(daily) | Buy Now 

 India is celebrating its 72nd Independence Day and so are we! It¡¯s day to celebrate our past, enjoy the present and be optimistic about the future. What would be the best way to do this? The best way is to build things for future and enable more and more people to do so. That¡¯s what we will be doing this Independence Day. Let me tell what is in store. Dr. Avik Sarkar is the Head of the Data Science Cell as part of the Indian government¡¯s NITI Aayog initiative. He is involved in the effective use of artificial intelligence, big data and data science techniques for social good in areas of real-time governance, healthcare, agriculture monitoring, education, energy, etc. This exclusive podcast will feature Kunal in conversation with Dr. Avik about the state of the data science field in India, what and how NITI Aayog is using data science to work on various challenges in multiple Indian sectors, among other things. Happy listening! We will offer incredible deals on our existing as well as upcoming training courses<U+00A0>.<U+00A0>It all kicks off on 11th August midnight. Check them out. Whether you want to learn data science, machine learning, computer vision, MS Excel, or want to understand what Artificial Intelligence is from a business leader¡¯s perspective, we are offering each of these courses at flat 60% off. An unmissable offer! Analytics Vidhya¡¯s flagship event DataHack Summit 2018 is one of the most anticipated and eagerly awaited machine learning, deep learning artificial intelligence and IoT conferences this year. It will be held on November 22-24 in Bengaluru. These are just some of the sectors we will be exploring in our Independence Day article (to be published on 14th November). Data science is a powerful tool so why shouldn¡¯t we use it for the betterment of this wonderful nation? We will provide links to resources like open datasets which you can download and contribute back to the community. It¡¯s both an informational piece as well as a call to action. All aboard the ¡®Data Science for good¡¯ express!"
"vidhya",2018-08-09,"Ultimate guide to handle Big Datasets for Machine Learning using Dask (in Python)","https://www.analyticsvidhya.com/blog/2018/08/dask-big-datasets-machine_learning-python/","

INDEPENDENCE DAY SALE: Get FLAT 60% OFF on All Courses | Use COUPON CODE: IDAY60 |
OFFER ENDS: 15th Aug 23:59 hrs IST | 
Valid for first 60 users(daily) | Buy Now 

 Have you ever tried working with a large dataset on a 4GB RAM machine? It starts heating up while doing simplest of machine learning tasks? This is a common problem data scientists face when working with restricted computational resources. When I started my data science journey using python, I almost immediately realized that the existing libraries have certain limitations when it comes to handling large datasets.<U+00A0>Pandas and Numpy are great libraries but they are not always computationally efficient, especially when there are GBs of data to manipulate. So what can you do to get around this obstacle? This is where Dask weaves its magic! It works with Pandas dataframes and Numpy data structures to help you perform data wrangling and model building using large datasets on not-so-powerful machines. Once you start using Dask, you won¡¯t look back. In this article, we will look at what Dask is, how it works, and how you can use it for working on large datasets. We will also take up a dataset and put Dask to good use. Let¡¯s begin! Let me illustrate these aforementioned limitations with a simple example. Suppose you have 4 balls (of different colors) and you are asked to separate them within an hour (based on the color) into different buckets. What if you are given a hundred balls and you have to separate them in an hour¡¯s time? That would be a tedious task but still sounds feasible. Imagine you are given a thousand balls and an hour to separate them into buckets. It is impossible for an individual to complete the task within the given time (in this case, the data is huge and the resources are limited). How would you accomplish this? The best bet would be to ask a few other people for help. You can call 9 other friends, give each of them 100 balls and ask them to separate these based on the color. In this case, 10 people are simultaneously working on the assigned task and together would be able to complete it faster than a single person would have (here you had a huge amount of data which you distributed among a bunch of people). Currently we use common libraries like pandas, numpy and scikit-learn for data preprocessing and model building. These libraries are not scalable and work on a single CPU. Dask however can scale up to a cluster of machines. To sum up, pandas and numpy are like the individual trying to sort the balls alone, while the group of people working together represent<U+00A0>Dask. Python is one of the most popular programming languages today and is widely used by data scientists and analysts across the globe. There are common python libraries (numpy, pandas, sklearn) for performing data science tasks and these are easy to understand and implement. But when it comes to working with large datasets using these python libraries, the run time can become very high due to memory constraints. These libraries usually work well if the dataset fits into the existing RAM. But if we are given a large dataset to analyze (like 8/16/32<U+00A0> GB or beyond), it would be difficult to process and model it. Unfortunately, these popular libraries were not designed to scale beyond a single machine. It is like asking a single person to separate a thousand balls in a limited time frame, it¡¯s quite unfair to ask! What should one do when faced with a dataset larger than what a single machine can process? This is where Dask comes into the picture. It is a python library that can handle moderately large datasets on a single CPU by using multiple cores of machines or on a cluster of machines (distributed computing). If you are familiar with pandas and numpy, you will find working with Dask fairly easy. Dask is popularly known as a ¡®parallel computing¡¯ python library that has been designed to run across multiple systems. Your next question would understandably be <U+2013> what is parallel computing? As in our example of separating the balls, 10 people doing the job simultaneously can be considered analogous to parallel computation. In technical terms, parallel computation is performing multiple tasks (or computations) simultaneously, using more than one resource. Dask can efficiently perform parallel computations on a single machine using multi-core CPUs. For example, if you have a quad core processor, Dask can effectively use all 4 cores of your system simultaneously for processing. In order to use lesser memory during computations, Dask stores the complete data on the disk, and uses chunks of data (smaller parts, rather than the whole data) from the disk for processing. During the processing, the intermediate values generated (if any) are discarded as soon as possible, to save the memory consumption. In summary, Dask can run on a cluster of machines to process data efficiently as it uses all the cores of the connected machines. One interesting fact here is that it is not necessary that all machines should have the same number of cores. If one system has 2 cores while the other has 4 cores, Dask can handle these variations internally. Dask supports the Pandas dataframe and Numpy array data structures to analyze large datasets. Basically, Dask lets you scale pandas and numpy with minimum changes in your code format. How great is that? Before we go ahead and explore the various functionalities provided by Dask, we need to setup our system first. Dask can be installed with conda, with pip, or directly from the source. This section explores all three options. Dask is installed in Anaconda by default. You can update it using the following command: To install Dask using pip, simply use the below code in your command prompt/terminal window: To install Dask from source, follow these steps: 1. Clone the git repository 2. Use pip to install all dependencies Now that we are familiar with Dask and have set up our system, let us talk about the Dask interface before we jump over to the python code. Dask provides several user interfaces, each having a different set of parallel algorithms for distributed computing. For data science practitioners looking for scaling numpy, pandas and scikit-learn, following are the important user interfaces: The dataset used for implementation in this article is AV¡¯s<U+00A0>Black Friday practice problem . You can download the dataset from the given link and follow along with the code blocks below. Let¡¯s get started! A large numpy array is divided into smaller arrays which, when grouped together, form the Dask array. In simple words, Dask arrays are distributed numpy arrays! Every operation on a Dask array triggers operations on the smaller numpy arrays, each using a core on the machine. Thus all available cores are used simultaneously enabling computations on arrays which are larger than the memory size. Below is an image to help you understand what a Dask array looks like: As you can see, a number of numpy arrays are arranged into grids to form a Dask array. While creating a Dask array, you can specify the chunk size which defines the size of the numpy arrays. For instance, if you have 10 values in an array and you give the chunk size as 5, it will return 2 numpy arrays with 5 values each. In summary, below are a few important features of Dask arrays below: We will now have a look at some simple cases for creating arrays using Dask. As you can see here, I had 11 values in the array and I used the chunk size as 5.<U+00A0> This distributed my array into three chunks, where the first and second blocks have 5 values each and the third one has 1 value. Dask arrays support most of the numpy functions. For instance, you can use .sum() or .mean(), as we will do now. Here, we simply converted our numpy array into a Dask array and used .mean() to do the operation. In all the above codes, you must have noticed that we used .compute() to get the results. This is because when we simply use dask_array.mean(), Dask builds a graph of tasks to be executed. To get the final result, we use the<U+00A0>.compute() function which triggers the actual computations. We saw that multiple numpy arrays are grouped together to form a Dask array. Similar to a Dask array, a Dask dataframe consists of multiple smaller pandas dataframes. A large pandas dataframe splits row-wise to form multiple smaller dataframes. These smaller dataframes are present on a disk of a single machine, or multiple machines (thus allowing to store datasets of size larger than the memory). Each computation on a Dask dataframe parallelizes operations on the existing pandas dataframes. Below is an image that represents the structure of a Dask dataframe: The APIs offered by the Dask dataframe are very similar to that of the pandas dataframe. Now, let¡¯s perform some basic operations on Dask dataframes. Time to load up the Black Friday dataset you had downloaded earlier! The Black Friday dataset used here has 5,50,068 rows. On using Dask, the read time<U+00A0>reduced more than ten times as compared to using pandas! Dask ML provides scalable machine learning algorithms in python which are compatible with scikit-learn. Let us first understand how scikit-learn handles the computations and then we will look at how Dask performs these operations differently. A user can perform parallel computing using scikit-learn (on a single machine) by setting the parameter njobs = -1. Scikit-learn uses Joblib<U+00A0>to perform these parallel computations. Joblib is a library in python that provides support for parallelization. When you call the .fit() function, based on the tasks to be performed (whether it is a hyperparameter search or fitting a model), Joblib<U+00A0>distributes the task over the available cores. To understand Joblib<U+00A0>in detail, you can have a look at this documentation. Even though parallel computations can be performed using scikit-learn, it cannot be scaled to multiple machines. On the other hand, Dask works well on a single machine and can also be scaled up to a cluster of machines. Dask has a central task scheduler and a set of workers. The scheduler assigns tasks to the workers. Each worker is assigned a number of cores on which it can perform computations. The workers provide two functions: Below is an example that explains how a conversation between a scheduler and workers looks like (this has been given by one of the developers of Dask, Matthew Rocklin): The central task scheduler sends jobs (python functions) to lots of worker processes, either on the same machine or on a cluster: This should give you a clear idea about how Dask works. Now we will discuss about machine learning models and Dask-search CV! Dask-ML provides scalable machine learning in python which we will discuss in this section. Implementation for the same will be covered in section 6. Let us first get our systems ready. Below are the installation steps for Dask-ML. 1. Parallelize Scikit-Learn Directly As we have seen previously, sklearn provides parallel computing (on a single CPU) using Joblib. In order to parallelize multiple sklearn estimators, you can directly use Dask by adding a few lines of code (without having to make modifications in the existing code). The first step is to import client from dask.distributed. This command will create a local scheduler and worker on your machine. To read more about the Dask client, you can refer to<U+00A0>this document. The next step will be to instantiate dask joblib in the backend. You need to import parallel_backend from sklearn joblib like I have shown below. 2. Reimplement Algorithms with Dask Array For simple machine learning algorithms which use Numpy arrays, Dask ML re-implements these algorithms. Dask replaces numpy arrays with Dask arrays to achieve scalable algorithms. This has been implemented for: A.<U+00A0> Linear model example B. Pre-processing example C. Clustering example Hyperparameter tuning is an important step in model building and can greatly affect the performance of your model. Machine learning models have multiple hyperparameters and it is not easy to figure out which parameter would work best for a particular case. Performing this task manually is generally a tedious process. In order to simplify the process, sklearn provides Gridsearch for hyperparameter tuning. The user is required to give the values for parameters and Gridsearch gives you the best combination of these parameters. Consider an example where you choose a random forest technique to fit the dataset. Your model has three important tunable parameters <U+2013> parameter 1, parameter 2 and parameter 3. You set the values for these parameters as: Parameter 1 <U+2013> Bootstrap = True Parameter 2 <U+2013> max_depth <U+2013> [8, 9]
 Parameter 3 <U+2013> n_estimators : [50, 100 , 200]
 sklearn Gridsearch : For each combination of the parameters, sklearn Gridsearch executes the tasks, sometimes ending up repeating a single task multiple times. As you can see from the below graph, this is not exactly the most efficient method: Dask-Search CV:<U+00A0>Parallel to Gridsearch CV in sklearn, Dask provides a library called Dask-search CV (Dask-search CV is now included in Dask ML). It merges steps so that there are less repetitions. Below are the installation steps for Dask-search. The following graph explains the working of Dask-Search CV: We will implement what we have learned so far on the Black Friday dataset and see how it works. Data exploration and treatment is out of the scope of this article as I will only illustrate how to use Dask for a ML problem.<U+00A0>In case you are interested in these steps, you can check out the below mentioned articles: 1. Using a simple logistic regression model and making predictions This will give you the predictions on the given test set. 2. Using grid search and random forest algorithm to find the best set of parameters. On printing grid_search.best_params_ you will get the best combination of parameters for the given mode. I have varied only a few parameters here but once you are comfortable with using dask-search, I would suggest experimenting with more parameters while using multiple varying values for each parameter. One very common question that I have seen while exploring Dask is: How is Dask different from Spark and which one is preferred? There is no hard and fast rule that says one should use Dask (or Spark), but you can make your choice based on the features offered by them and whichever one suits your requirements more. Here are some important differences between Dask and Spark : I have recently started using Dask and am still exploring this amazing library. It is comforting to know that I don¡¯t have to explore a whole new tool in order to build my models when faced with large datasets. The best part about Dask is that it offers an interface very similar to pandas and there is a very slight (sometimes negligible) difference in the code. There are innumerable tasks that one can perform using Dask thanks to the drastic reduction in processing time. Go ahead and explore this library and share your experience in the comments section below. Thanks for sharing. It sounds like a promising library. Glad you liked it! Hello Aishwarya, That¡¯s a really awesome utility. Thanks for sharing it.  I would like to make an edit in Section 6.2 below
***************************************************************
# Instantiate the grid search model
grid_search = dcv.GridSearchCV(estimator = rf, param_grid = param_grid, cv = 3)
***************************************************************
Here we need to ¡°import dask_searchcv as dcv¡± to make this command work.
And before that one has to install in the env if it¡¯s not available. Please update it for the benefit of others. Hi Nitin, Thanks for pointing it out. I missed that line with the code. Have updated the same in the article. Also, the installation steps for dask_searchcv are provided in the previous section. Good article. It would be an added value to the Dask if we added the comparison on runtime stats. Will give a try to use this python package to deal with the huge volume of data! Hi Jenarthanan, I actually did add a comparison on reading the file using dask and pandas. When pandas took 541 ms, dask took only 35.9 ms to read the file. Thank you very much for sharing this. I can see that Dask has got inherently array or data frame structures, which seems promising, but in terms of performance, how is it comparable with mpi library, which is also used for parallel programming? Hi Sahar, Comparing Dask and mpi library in terms of performance, MPI outperforms dask. In fact, Matthew Rocklin has said in an interview, ¡°Dask not going to out-compete MPI on super computers¡±. Nice artical, thanks! just a quick one in section ¡°Set up your system: Dask Installation¡± , we might want to specify how to install it in cluster.  Means what are the steps needed to be done for making dask work on more than one machine.  Cheers! Hi Sandeep, Thanks for the suggestion. Will update it soon. Hey, I had a problem executing this statement. Pl see screen shot below:
X.chunks
AttributeError Traceback (most recent call last)
in ()
1 #to see the size of each chunk
<U+2014>-> 2 X.chunks AttributeError: ¡®numpy.ndarray¡¯ object has no attribute ¡®chunks¡¯ Hi Anshul, Looks like X in your case is a numpy array. Convert it into a dask array and then execute X.chunks. i have just copy pasted ur code from section 5.1 till the point where i get this X.chunks error
Please elaborate what could be wrong. Hi,"
"vidhya",2018-08-09,"Infographic <U+2013> A Complete Guide on Getting Started with Deep Learning in Python","https://www.analyticsvidhya.com/blog/2018/08/infographic-complete-deep-learning-path/","

INDEPENDENCE DAY SALE: Get FLAT 60% OFF on All Courses | Use COUPON CODE: IDAY60 |
OFFER ENDS: 15th Aug 23:59 hrs IST | 
Valid for first 60 users(daily) | Buy Now 

 You seem to come across the term ¡®Deep Learning¡¯ everywhere these days. It¡¯s all pervasive and seems to be at the heart of all AI related research. It has even spawned new and never-thought-of-before innovations! But how can you learn it? There are way too many resources out there, spread in a very unstructured and not a very beginner friendly manner. You complete a course on one platform, move to another course on a different platform, and so on. You learn, but not in any logical or sequential manner. That¡¯s a bad idea."
"vidhya",2018-08-05,"DataHack Radio Episode #6: Exploring Techniques and Strategy with Coursera¡¯s Head of Data Science, Emily Glassberg Sands","https://www.analyticsvidhya.com/blog/2018/08/datahack-radio-episode-4-coursera-data-science-emily-glassberg-sands/","

INDEPENDENCE DAY SALE: Get FLAT 60% OFF on All Courses | Use COUPON CODE: IDAY60 |
OFFER ENDS: 15th Aug 23:59 hrs IST | 
Valid for first 60 users(daily) | Buy Now 

 Have you ever wondered how Coursera uses data science? Sure we have all taken (or heard of) their courses but how does the platform make use of the amount of data that¡¯s generated? How does their pricing strategy work for certificates? How is their data science team structured? What tools and techniques do they use? These are just some of the questions answered in this phenomenal podcast. We had the pleasure of hosting Coursera¡¯s Head of Data Science, Emily Glassberg Sands, who gave us a detailed and thorough explanation of how Coursera functions behind the scenes. It makes for very fascinating listening and you will learn a whole bunch of data science and machine learning stuff throughout. In this article, we have listed a few snippets from Kunal¡¯s conversation with Emily. Click the above SoundCloud button to listen to the podcast! You can subscribe to DataHack Radio or listen to previous episodes on any of the below platforms: Emily joined Coursera over four years ago after successfully completing her Ph.D in Economics from Harvard University. Before that, she completed her undergraduate degree from Princeton University in Economics as well. She co-authored two papers during her Ph.D which make for very interesting reads (they are available on her LinkedIn profile and are very relevant for data scientists). She had not initially applied to be a data scientist at Coursera, instead opting to apply to the Partnerships division. She liked Coursera¡¯s mission and during her initial few months there, she worked with various machine learning folks (half of the original team was comprised of machine learning researchers from Stanford).<U+00A0>Emily was the first data science hire at Coursera and is now their Head of Data Science! Her research during her graduation years was exclusively in MATLAB. She trained herself in R and Python using books (courses back then weren¡¯t as good as they are now) before joining Coursera and learned quite a lot on the job as well. Emily elaborated on Coursera¡¯s growth since she joined in 2014. The platform has seen a rapid rise in both the number of users and the amount of content they have. The team has grown to over 300 people across the organization, with the product and engineering department making up half of that number. Emily¡¯s data science team is currently comprised of the below three roles, along with their functions: So which language(s) does Coursera¡¯s data science team use for day-to-day tasks? R and Python! Everyone on the team is expected to know and work with these two popular languages. For the content discovery aspect that we see on Coursera¡¯s platform, it¡¯s important for the data science team to establish the right metadata (understanding features of the content and Coursera¡¯s users). This is followed by building relatively lightweight logistic regression models to recommend the best content to the end user.<U+00A0>There are also a few black box models which the team experiments with. But the biggest boon has been what Emily calls ¡°skills graphs¡± or ¡°knowledge graphs¡±. This contains a bunch of metadata about content and learners. When you combine these two, you get very powerful predictions that Coursera leverages in it¡¯s end product. Building the graph however, is a bit complex. It maps about 40,000 skills to the available content types and this is what powers various machine learning models that work on recommendations. The team has been working on this knowledge graph since almost two years. At this point Emily offered some valuable insights into what a data scientist should expect <U+2013> it wasn¡¯t a one step process. They built out one part of the knowledge graph, tried it out in a practical situation, and then went ahead with building the rest, piece by piece. If you are interested in NLP or just want to know how a data science project functions from scratch, you should listen to this section in the podcast. Collaborative filtering, one of the most popular recommendation techniques, was initially being used by Coursera before they started using tons of metadata to refine and improve on it. If you have the amount of information and data that the team has collected over the years, why not use it to improve the experience for it¡¯s users? Emily wanted to improve the credential value of Coursera¡¯s certificates when she started working there. Her working hypothesis, before she had a look at the data, was that people in developing countries would value the certificate as it would help them in their job applications. The data revealed otherwise <U+2013> people in these countries were not taking these certificates. Using various econometric and data science techniques including regression analysis, fixed effects model, etc. she discovered that learners in developing markets were far more price sensitive than learners in developed markets. It sounds pretty intuitive now but was not something the team had thought of back then. Now came the question of how to price these certificates. Emily and her team ruled out trying A/B testing from the outset because of how unfair that could be for certain people. Instead, they went with a quasi experimental design. Emily took a bundle of developing markets and applied synthetic control methods and difference-in-difference analysis. Emily has described this in much more detail in the podcast and it makes for really interesting listening. This is a pretty common issue observed in today¡¯s MOOC dominated world. People start a course but leave halfway through due to various reasons. Emily discussed how Coursera divides their approach into two parts to handle this: After experimenting with a predictive model that identified at-risk learners, the team then built several advanced models to recognize the reason why learners were dropping off at certain points. They have built several ¡°intervention points¡± which help them understand where the user might need a nudge, or extra help, and then take action accordingly. On the instructor side of things, Coursera lets them do A/B testing to understand their audience. Two versions of a course are created at the backend and the instructor can edit one of those to make it a bit different. Then when learners enroll in the course, they are shown one of these two versions by a randomization method. ¡°Team building, for me, is about collecting a superstar team.¡± Emily looks at a number of components when building her data science team. I have mentioned a few crucial ones below: Analytics Vidhya has featured Emily in the ¡°most influential women in data science¡± list two years running now. She is an advocate of diversity in data science and enlightened us with her opinions on the subject in this podcast. Below are a few pointers she mentioned which hiring companies should take note of. When crafting a job description, she makes sure it¡¯s inclusive and gender neutral. She also believes it¡¯s important to invest in diversity early when you have a small team. Co-hosting events with the ¡®Women who Code¡¯ organization has also worked out really well for Coursera. Small things in the interview process also make a world of difference <U+2013> making sure that all candidates are asked the same questions, ensuring feedback from interviewers is not being shown to each other until they have submitted their own feedback, etc. There are a lot more really thoughtful points in the podcast. ¡°Both are tremendously valuable in isolation, and particularly valuable when combined.¡± Emily agreed with Kunal¡¯s assessment that people who comes from an economics background have more intuitive insights and hypothesis as compared to folks who come from computer science degrees. She mentioned that when taking these two separately, they have their own unique value. But they become truly valuable when they¡¯re combined."
