"site","date","headline","url_address","text"
"vidhya",2018-10-25,"Stock Prices Prediction Using Machine Learning and Deep Learning Techniques (with Python codes)","https://www.analyticsvidhya.com/blog/2018/10/predicting-stock-price-machine-learningnd-deep-learning-techniques-python/","Predicting how the stock market will perform is one of the most difficult things to do. There are so many factors involved in the prediction <U+2013> physical factors vs. physhological, rational and irrational behaviour, etc. All these aspects combine to make share prices volatile and very difficult to predict with a high degree of accuracy. Can we use machine learning as a game changer in this domain? Using features like the latest announcements about an organization, their quarterly revenue results, etc., machine learning techniques have the potential to unearth patterns and insights we didn¡¯t see before, and these can be used to make unerringly accurate predictions. In this article, we will work with historical data about the stock prices of a publicly listed company. We will implement a mix of machine learning algorithms to predict the future stock price of this company,<U+00A0>starting with simple algorithms like averaging and linear regression, and then moving on to advanced techniques like Auto ARIMA and LSTM. The core idea behind this article is to showcase how these algorithms are implemented, so I will briefly describe the technique and provide relevant links to brush up on the concepts as and when necessary. In case you¡¯re a newcomer to the world of time series,<U+00A0>I suggest going through the following articles first: We¡¯ll dive into the implementation part of this article soon, but first it¡¯s important to establish what we¡¯re aiming to solve. Broadly, stock market analysis is divided into two parts <U+2013> Fundamental Analysis and Technical Analysis. As you might have guessed, our focus will be on the technical analysis part. We¡¯ll be using a dataset from<U+00A0>Quandl<U+00A0>(you can find historical data for various stocks here) and for this particular project, I have used the data for ¡®Tata Global Beverages¡¯. Time to dive in! We will first load the dataset and define the target variable for the problem: There are multiple variables in the dataset <U+2013> date, open, high, low, last, close, total_trade_quantity, and turnover. Another important thing to note is that the market is closed on weekends and public holidays.Notice the above table again, some date values are missing <U+2013> 2/10/2018, 6/10/2018, 7/10/2018. Of these dates, 2nd is a national holiday while 6th and 7th fall on a weekend. The profit or loss calculation is usually determined by the closing price of a stock for the day, hence we will consider the closing price as the target variable. Let¡¯s plot the target variable to understand how it¡¯s shaping up in our data: In the upcoming sections, we will explore these variables and use different techniques to predict the daily closing price of the stock. ¡®Average¡¯ is easily one of the most common things we use in our day-to-day lives. For instance, calculating the average marks to determine overall performance, or finding the average temperature of the past few days to get an idea about today¡¯s temperature <U+2013> these all are routine tasks we do on a regular basis. So this is a good starting point to use on our dataset for making predictions. The predicted closing price for each day will be the average of a set of previously observed values. Instead of using the simple average, we will be using the moving average technique which uses the latest set of values for each prediction. In other words, for each subsequent step, the predicted values are taken into consideration while removing the oldest observed value from the set. Here is a simple figure that will help you understand this with more clarity. We will implement this technique on our dataset. The first step is to create a dataframe that contains only the Date and Close price columns, then split it into train and validation sets to verify our predictions. While splitting the data into train and validation, we cannot use random splitting since that will destroy the time component. So here I have set the last year¡¯s data into validation and the 4 years¡¯ data before that into train. The next step is to create predictions for the validation set and check the RMSE using the actual values. Just checking the RMSE does not help us in understanding how the model performed. Let¡¯s visualize this to get a more intuitive understanding. So here is a plot of the predicted values along with the actual values. The RMSE value is close to 105 but the results are not very promising (as you can gather from the plot). The predicted values are of the same range as the observed values in the train set (there is an increasing trend initially and then a slow decrease). In the next section, we will look at two commonly used machine learning techniques <U+2013> Linear Regression and kNN, and see how they perform on our stock market data. The most basic machine learning algorithm that can be implemented on this data is linear regression. The linear regression model returns an equation that determines the relationship between the independent variables and the dependent variable. The equation for linear regression can be written as: Here, x1, x2,¡¦.xn represent the independent variables while the coefficients ¥è1, ¥è2, ¡¦. ¥èn<U+00A0> represent the weights. You can refer to the following article to study linear regression in more detail: For our problem statement, we do not have a set of independent variables. We have only the dates instead. Let us use the date column to extract features like <U+2013> day, month, year, <U+00A0>mon/fri etc. and then fit a linear regression model. We will first sort the dataset in ascending order and then create a separate dataset so that any new feature created does not affect the original data. This creates features such as: ¡®Year¡¯, ¡®Month¡¯, ¡®Week¡¯, ¡®Day¡¯, ¡®Dayofweek¡¯, ¡®Dayofyear¡¯, ¡®Is_month_end¡¯, ¡®Is_month_start¡¯, ¡®Is_quarter_end¡¯, ¡®Is_quarter_start¡¯, <U+00A0>¡®Is_year_end¡¯, and<U+00A0> ¡®Is_year_start¡¯. Note: I have used add_datepart from fastai library. If you do not have it installed, you can simply use the command pip install fastai. Otherwise, you can create these feature using simple for loops in python. I have shown an example below. Apart from this, we can add our own set of features that we believe would be relevant for the predictions. For instance, my hypothesis is that the first and last days of the week could potentially affect the closing price of the stock far more than the other days. So I have created a feature that identifies whether a given day is Monday/Friday or Tuesday/Wednesday/Thursday. This can be done using the following lines of code: If the day of week is equal to 0 or 4, the column value will be 1, otherwise 0. Similarly, you can create multiple features. If you have some ideas for features that can be helpful in predicting stock price, please share in the comment section. We will now split the data into train and validation sets to check the performance of the model. The RMSE value is higher than the previous technique, which clearly shows that linear regression has performed poorly. Let¡¯s look at the plot and understand why linear regression has not done well: Linear regression is a simple technique and quite easy to interpret, but there are a few obvious disadvantages. One problem in using regression algorithms is that the model overfits to the date and month column. Instead of taking into account the previous values from the point of prediction, the model will consider the value from the same date a month ago, or the same date/month a year ago. As seen from the plot above, for January 2016 and January 2017, there was a drop in the stock price. The model has predicted the same for January 2018. A linear regression technique can perform well for problems such as Big Mart sales where the independent features are useful for determining the target value. Another interesting ML algorithm that one can use here is kNN (k nearest neighbours). Based on the independent variables, kNN finds the similarity between new data points and old data points. Let me explain this with a simple example. Consider the height and age for 11 people. On the basis of given features (¡®Age¡¯ and ¡®Height¡¯), the table can be represented in a graphical format as shown below: To determine the weight for ID #11, kNN considers the weight of the nearest neighbors of this ID. The weight of ID #11 is predicted to be the average of it¡¯s neighbors. If we consider three neighbours (k=3) for now, the weight for ID#11 would be = (77+72+60)/3 = 69.66 kg. For a detailed understanding of kNN, you can refer to the following articles: Introduction to k-Nearest Neighbors: Simplified<U+00A0> A Practical Introduction to K-Nearest Neighbors Algorithm for Regression Using the same train and validation set from the last section: There is not a huge difference in the RMSE value, but a plot for the predicted and actual values should provide a more clear understanding. The RMSE value is almost similar to the linear regression model and the plot shows the same pattern. Like linear regression, kNN also identified a drop in January 2018 since that has been the pattern for the past years. We can safely say that regression algorithms have not performed well on this dataset. Let¡¯s go ahead and look at some time series forecasting techniques to find out how they perform when faced with this stock prices prediction challenge. ARIMA is a very popular statistical method for time series forecasting. ARIMA models take into account the past values to predict the future values. There are three important parameters in ARIMA: Parameter tuning for ARIMA consumes a lot of time. So we will use auto ARIMA which automatically selects the best combination of (p,q,d) that provides the least error. To read more about how auto ARIMA works, refer to this article: As we saw earlier, an auto ARIMA model uses past data to understand the pattern in the time series. Using these values, the model captured an increasing trend in the series. Although the predictions using this technique are far better than that of the previously implemented machine learning models, these predictions are still not close to the real values. As its evident from the plot, the model has captured a trend in the series, but does not focus on the seasonal part. In the next section, we will implement a time series model that takes both trend and seasonality of a series into account. There are a number of time series techniques that can be implemented on the stock prediction dataset, but most of these techniques require a lot of data preprocessing before fitting the model. Prophet, designed and pioneered by Facebook, is a time series forecasting library that requires no data preprocessing and is extremely simple to implement. The input for Prophet is a dataframe with two columns: date and target (ds and y). Prophet tries to capture the seasonality in the past data and works well when the dataset is large. Here is an interesting article that explains Prophet in a simple and intuitive manner: Prophet (like most time series forecasting techniques) tries to capture the trend and seasonality from past data. This model usually performs well on time series datasets, but fails to live up to it¡¯s reputation in this case. As it turns out, stock prices do not have a particular trend or seasonality. It highly depends on what is currently going on in the market and thus the prices rise and fall. Hence forecasting techniques like ARIMA, SARIMA and Prophet would not show good results for this particular problem. Let us go ahead and try another advanced technique <U+2013> Long Short Term Memory (LSTM). LSTMs are widely used for sequence prediction problems and have proven to be extremely effective. The reason they work so well is because LSTM is able to store past information that is important, and forget the information that is not. LSTM has three gates: For a more detailed understanding of LSTM and its architecture, you can go through the below article: For now, let us implement LSTM as a black box and check it¡¯s performance on our particular data. Wow! LSTM has easily outshone any algorithm we saw so far. The LSTM model can be tuned for various parameters such as changing the number of LSTM layers, adding dropout value or increasing the number of epochs. But are the predictions from LSTM enough to identify whether the stock price will increase or decrease? Certainly not! As I mentioned at the start of the article, stock price is affected by the news about the company and other factors like demonetization or merger/demerger of the companies. There are certain intangible factors as well which can often be impossible to predict beforehand. Time series forecasting is a very intriguing field to work with, as I have realized during my time writing these articles. There is a perception in the community that it¡¯s a complex field, and while there is a grain of truth in there, it¡¯s not so difficult once you get the hang of the basic techniques. I am interested in finding out how LSTM works on a different kind of time series problem and encourage you to try it out on your own as well. If you have any questions, feel free to connect with me in the comments section below. Isn¡¯t the LSTM model using your ¡°validation¡± data as part of its modeling to generate its predictions since it only goes back 60 days. Your other techniques are only using the ¡°training¡± data and don¡¯t have the benefit of looking back 60 days from the target prediction day. Is this a fair comparison? Hi James, The idea isn¡¯t to compare the techniques but to see what works best for stock market predictions. Certainly for this problem LSTM works well, while for other problems, other techniques might perform better. We can add a lookback component with LSTM is an added advantage I think that you cannot say LSTM works well because what it actually does is to predict one day ahead based on the recent 60 days. In other words, the model just go over all the validation data daily basis to predict ¡°tomorrow¡±. This is a totally different prediction scheme from the other prediction methods, which have to predict the entire validation data points without seeing any of information in the validation data. If you use the ¡°daily basis prediction¡± scheme for other mothods, any of methods would produce a good result, I guess. Hi Teru, When James first pointed out, I started looking at how can I use validation in other models (its simpler with LSTM). For ARIMA and PROPHET, the input can only be a univariate series so we can make prediction for one day, change the training set (add that day¡¯s value) after each prediction and retrain before predicting for the next day. For moving average and regression it should be comparatively easier. If you both have any suggestions as to how can I update train data with each day¡¯s values, do share your ideas, I am really interested in finding out how the results turn out to be! Getting index error <U+2013> <U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014>
IndexError Traceback (most recent call last)
in
1 #Results
<U+2014>-> 2 rms=np.sqrt(np.mean(np.power((np.array(valid[¡®Close¡¯]) <U+2013> np.array(valid[¡®Predictions¡¯])),2)))
3 rms IndexError: only integers, slices (`:`), ellipsis (`¡¦`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices Hi Jay, Please use the following command before calculating rmse valid['Predictions'] = 0valid['Predictions'] = closing_price. I have updated the same in the article After running the following codes-
train[¡®Date¡¯].min(), train[¡®Date¡¯].max(), valid[¡®Date¡¯].min(), valid[¡®Date¡¯].max() (Timestamp(¡®2013-10-08 00:00:00¡¯),
Timestamp(¡®2017-10-06 00:00:00¡¯),
Timestamp(¡®2017-10-09 00:00:00¡¯),
Timestamp(¡®2018-10-08 00:00:00¡¯)) I am getting the following error :
name ¡®Timestamp¡¯ is not defined Please help. Hi Pankaj,  The command is only train[¡®Date¡¯].min(), train[¡®Date¡¯].max(), valid[¡®Date¡¯].min(), valid[¡®Date¡¯].max() , the timestamp is the result I got by running the above command. Hi Aishwarya, Just curious. LSTM works just TOO well !! Is splitting dataset to train & valid step carry out after the normalizing step ?! i.e.
#converting dataset into x_train and y_train
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(dataset) then dataset = new_data train = dataset[:987]
valid = dataset[987:] Then this
x_train, y_train = [], []
for i in range(60,len(train )): # <- replace dataset with train ?!
x_train.append(scaled_data[i-60:i,0])
y_train.append(scaled_data[i,0])
x_train, y_train = np.array(x_train), np.array(y_train) Guide me on this. Thanks Hi Zarief, Yes, the train and test set are created after scaling the data using the for loop :  x_train, y_train = [], []
for i in range(60,len(train )):
x_train.append(scaled_data[i-60:i,0]) #we have used the scaled data here
y_train.append(scaled_data[i,0])
x_train, y_train = np.array(x_train), np.array(y_train) Secondly, the command dataset = new_data.values will be before scaling the data, as shown in the article, since dataset is used for scaling and hence must be defined before.  hi I¡¯m getting below error¡¦
¡±¡±>>> #import packages
>>> import pandas as pd Traceback (most recent call last):
File ¡°¡±, line 1, in
import pandas as pd
ImportError: No module named pandas¡±¡±¡±¡± Hi rohit, Is the issue resolved? Have you worked with pandas previously? Hi.. Thanks for nicely elaborating LSTM implementation in the article. However, in LSTM rms part if you can guide, as I am getting the following error :  valid[¡®Predictions¡¯] = 0.0
valid[¡®Predictions¡¯] = closing_price
rms=np.sqrt(np.mean(np.power((np.array(valid[¡®Close¡¯])-np.array(valid[¡®Predictions¡¯])),2)))
rms ##############################################################################
IndexError Traceback (most recent call last)
in ()
<U+2014>-> 1 valid[¡®Predictions¡¯] = 0.0
2 valid[¡®Predictions¡¯] = closing_price
3 rms=np.sqrt(np.mean(np.power((np.array(valid[¡®Close¡¯])-np.array(valid[¡®Predictions¡¯])),2)))
4 rms IndexError: only integers, slices (`:`), ellipsis (`¡¦`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices Still same error <U+2013>  <U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014><U+2014>
IndexError Traceback (most recent call last)
in
<U+2014>-> 1 valid[¡®Predictions¡¯] = closing_price IndexError: only integers, slices (`:`), ellipsis (`¡¦`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices And also why are we doing valid[¡®Predictions¡¯] = 0 and valid[¡®Predictions¡¯] = closing_price instead of valid[¡®Predictions¡¯] = closing_price Yes you can skip the line but it will still show an error because the index hasn¡¯t been defined. Have you followed the code from the start? Please add the following code lines and check if it works  new_data.index = data[¡®Date¡¯] #considering the date column has been set to datetime format
valid.index = new_data[987:].index
train.index = new_data[:987].index Let me know if this works. Other wise share the notebook you are working on and I will look into it. Hi, Nice article. I have installed fastai but I am getting the following error:
ModuleNotFoundError: No module named ¡®fastai.structured¡¯ Any idea? Hi Roberto, Directly clone it from here : https://github.com/fastai/fastai . Let me know if you still face an issue."
